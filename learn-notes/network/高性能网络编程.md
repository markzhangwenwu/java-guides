
### select

#### 标准输入、套接字等看作I/O的一路，多路复用是指：任何一路有"事件"发生的情况下，通知应用程序去处理相应的I/O事件

##### 监听事件

1. 标准输入文件描述符准备好可以读

2. 监听套接字准备好，新的连接已经建立成功

3. 已连接套接字准备好可以写

4. 如果一个I/O 事件等待超过了10秒，发生了超时事件

#### 使用select函数，通知内核挂起进程，当一个或多IO事件发生后，控制权返还给应用程序，由应用程序进行IO事件的处理

1. 检测IO事件发生（阻塞）

2. 进行IO数据读写（同步)）

- 在移除阻塞点同时检测多个来自IO的事件。

````

int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);

返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1

maxfd: 表示的是待测试的描述符基数，它的值是待测试的最大描述符加1

readset：读描述符集合

writeset: 写描述符集合

exceptset: 异常描述符集合

timeout：如果为空，表示如果没有I/O事件发送，则select一直等待；若为非0值，表示等待固定一段时间后从阻塞调用中返回

````

#### 支持文件描述符个数有1024的限制


### poll

````
int poll(struct pollfd *fds,unsigned long nfds,int timeout);

返回值：若有就绪描述符则为其数目，若超时则为0，若出错则为-1

````

#### 突破了文件描述符的个数限制



### epoll

- epoll通过改进的接口设计，避免了用户态-内核态频繁数据拷贝，大大提高了系统性能。

- 条件触发的意思是只要满足事件的条件，比如有数据需要读，就一直不断地把这个事件传递给用户；边缘触发的意思是只有第一次满足条件的时候才触发，之后就不再传递同样的事件了。

- epoll返回的是有事件发生的数组，而poll返回的是准备好的个数，每次poll函数返回都要遍历注册的描述符结合数组尤其是数量越大遍历次数就越多。